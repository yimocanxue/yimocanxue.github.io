---
title: 结构和联合
categories:
  - C语言
  - 基本语法
tags:
  - struct
  - union
  - 结构体
  - 联合
abbrlink: 667c01ef
date: 2019-01-29 18:55:23
---



C语言中有两种聚合数据类型，数组和结构，数组是相同元素的集合，而结构可以存储不同类型的元素，这些元素称为结构的成员(member)，每个成员都有自己的名字和类型。

另外，结构变量是一种标量，这和数组有很大的区别，在绝大多数表达式中，数组名的值为指向数组第一个元素的指针(例外: sizeof 数组名返回整个数组占用字节大小，&array返回指向整个数组的指针，而不是指向第一个元素的指针的指针)。

### 结构声明

```c
struct tag {member-list} variable-list;
```

tag、member-list、variable-list都是可选的，但是除了tag，其它可选部分至少出现2个。

下面是几种常见的基本声明：

```c
// 合法，不完整声明
struct Node;
// 合法
struct Point {
    int x;
    int y;
};
// 合法
struct {
    int a;
    int b;
} x;
// 合法
struct {
    int a;
    int b;
} y,*z;
// 非法
struct self_ref {
    int a;
    struct self_ref b;
};
// 合法
struct self_ref2 {
    int a;
    struct self_ref2 b;
};

```



- 不完整声明
  - 声明语句只有tag
  - 一般用在结构体相互引用(依赖)的的情形。

- 声明Point结构时并不分配内存

  这是因为这里只是声明一种类型，而没有声明变量，因此不占用内存。

- 结构变量x、y是两种完全不同的类型

  尽管他们成员列表相同，但是他们是两种不同的结构类型，因此`z=&x`是非法的。

- 当结构自引用时，必须用指针

  self_ref的声明是非法的，因为成员b构成无线循环引用，而self_ref2是合法的，因为self_ref2中b是指针，编译器在结构本身长度确定之前就可以确定指针的长度。

- 最后，声明语句最后一定要有;结尾，尤其是没有声明变量时，结尾的花括号很容易误以为是语句块而少了分号。



如果上面的x、和y、z要共享相同的成员列表声明变成同一种类型，可以把标签tag和成员列表一起声明：

```c
struct Point {
    int a;
    int b;
};
struct Point x; // struct关键词不能省略
struct Point y, *z;

z = &x;
```

这个时候x和y类型就相同了，但是这个声明也有一个问题，太啰嗦了，在定义变量时，模式`struct Point 变量名`中struct关键词不能省略，这问题可以通过`typedef`关键词解决。

```c
typedef struct Point {  // 标签Point可省略
    int a;
    int b;
} myPoint;

myPoint x;
myPoint y, *z;

z = &x;
```

现在相当于给类型`struct Point`定义了一个别名`myPoint`。

最后，关于自引用结构的定义，注意下面的错误：

```c
typedef struct {
    int a;
    self_ref3 *b;
} self_ref3;
```

这个声明的问题在于类型名self_ref3在末尾才完成定义，因此成员列表的声明部分就没办法使用它，可以改成下面的格式：

```c
typedef struct self_ref3_tag {
    int a;
    struct self_ref3_tag *b;
} self_ref3;
```



##### 初始化



结构体初始化和数组初始化类似，一对花括号包含的以逗号分隔的值序列，根据成员定义顺序一一赋值，如果值少于成员，则剩余成员以缺省值初始化：

```c
struct INT_EX {
    int a;
    short b[5];
    struct {
        int a;
        char b;
    } c;
} = {
    10,
    {1,2,3},
    {5,'x'}
};
```





### 成员访问



- 结构体变量通过.操作符访问

```c
struct {
    int a;
    char b[20];
} x = {
    10,
    "hello world!"
};

printf("%d\n", x.a); // 输出10
printf("%s\n", x.b); // 输出hello world!

```



- 结构体指针通过->访问(指针间接访问)

```c
struct {
    int a;
    char b[20];
} x = { 10, "hello world!" }, *y;
y = &x;

printf("%d\n", y->a); // 输出10
printf("%s\n", y->b); // 输出hello world!

// 下面的代码和上面效果一样
printf("%d\n", (*y).a); // 输出10
printf("%s\n", (*y).b); // 输出hello world!

```







### 存储分配



结构体成员在内存中按照定义顺序存储，但是成员之间可能存在“空隙”，这是为了提升CPU寻址效率而采用对齐算法进行分配导致的，因为“空隙”的存在，通常结构占用字节数大于成员占用字节之和，C语言结构成员存储对齐规则如下：

- 每个成员的其实地址必须是自身类型大小的整数倍
- 结构体大小必须是占用字节数最大的成员的整数倍



根据对齐规则，分析下面的结构提占用字节数，为分析方便，下面用一个星号*表示一个实际占用的字节，一个横线-表示填充字节。

```c
struct str1 {
    char a;
    int b;
    char c;
}
/**
*  str1内存分配如下：
*   a       b       c
*   * - - - * * * * * - - -
*  a占用一字节，因此从内存0开始，而b占4字节，因此其地址开始位置必须为4的倍数
*  因此a后面填充3个字节，最后c占一个字节，因此紧跟b后，但是因为结构体占用字节数
*  必须为最大占用字节成员的倍数，即必须是b所占字节的整数倍，因此最后填充3个字节刚好12字节
*/
struct str2 {
    int b;
    char a;
    char c;
}
/**
*  str2内存分配如下：
*   b       a c      
*   * * * * * * - - 
*  成员和str1一样，只是调整了顺序，但是str2占用字节数为8字节，因此成员的顺序会影响内存分配。
*/

struct str3 {
    char a;
    int b;
    float c;
    double d;
}
/**
*  str3内存分配如下：
*   a       b       c               d
*   * - - - * * * * * * * * - - - - * * * * * * * * 
*  共占用24字节
*/

```









