---
title: 数据结构之（四）--- 队列
categories:
  - 算法/数据结构
  - 数据结构
tags:
  - 队列
  - queue
abbrlink: 5141ea00
date: 2019-02-11 22:27:28
---

### 队列ADT

队列(queue)和栈一样，也是一种表，和栈的主要区别在于插入和删除元素的方式，队列是先进先出(FIFO)，从队尾(rear)插入元素，称为入队(enqueue)，从队头(front)删除并返回元素，称为出队(dequeue)。

同栈一样，通常也由链表或数组实现队列，所有操作时间复杂度都为O(1)。



### 队列数组实现

ADT规范头文件queue.h：

```c
#ifndef _queue_h

struct QueueRecord;
typedef struct QueueRecord *Queue;

/**
 * 定义队列元素类型
 */
typedef int VType;

/**
 * 创建一个空队列
 * @param  maxElements 队列最大容量
 * @return             
 */
Queue createQueue (int maxElements);


/**
 * 判断队列是否为空
 * @param  q 
 * @return   
 */
int isEmpty (Queue q);

/**
 * 判断队列是否已满
 * @param  q 
 * @return   
 */
int isFull (Queue q);

/**
 * 释放一个队列
 * @param q 
 */
void disposeQueue (Queue q);

/**
 * 清空队列
 * @param q 
 */
void deleteAll (Queue q);

/**
 * 入队
 * @param x 
 * @param q 
 */
void enqueue (VType x, Queue q);

/**
 * 出队
 * @param  q 
 * @return   
 */
VType dequeue (Queue q);

/**
 * 返回队头元素
 * @param  q 
 * @return   
 */
VType front (Queue q);

/**
 * 显示队列元素
 * @param q 
 */
void show (Queue q);

#endif /* _queue_h */
```

实现文件queue.c：

```c
#include <stdio.h>
#include <stdlib.h>
#include "queue.h"
#define MinQueueSize (5) // 定义队列最小容量

struct QueueRecord {
	int capacity; // 队列容量
	int front; // 队头位置
	int rear; // 队尾位置
	int size; // 当前队列大小
	VType *array;
};

/**
 * 显示unix风格的错误
 * @param msg 
 */
void unix_error (char *msg) 
{
	printf("%s\n", msg);
	exit(0);
}

void *Malloc (size_t size) {
	void *p;
	if ((p = malloc(size)) == NULL)
		unix_error("malloc error!");
	return p;
}



/**
 * 创建一个空队列
 * @param  maxElements 队列最大容量
 * @return             
 */
Queue createQueue (int maxElements)
{
	Queue q;

	if (maxElements < MinQueueSize)
		unix_error("queue size is small");

	q = Malloc(sizeof (struct QueueRecord));

	q->capacity = maxElements;
	q->array = Malloc(sizeof (VType) * maxElements);
	// 清空队列
	deleteAll(q);

	return q;
}


/**
 * 判断队列是否为空
 * @param  q 
 * @return   
 */
int isEmpty (Queue q)
{
	return q->size == 0;
}

/**
 * 判断队列是否已满
 * @param  q 
 * @return   
 */
int isFull (Queue q)
{
	return q->size == q->capacity;
}

/**
 * 释放一个队列
 * @param q 
 */
void disposeQueue (Queue q) 
{
	if (q != NULL) {
		free(q->array);
		free(q);
	}
}

/**
 * 清空队列
 * @param q 
 */
void deleteAll (Queue q)
{
	q->size = 0;
	q->front = 1;
	q->rear = 0;
}

/**
 * 入队
 * @param x 
 * @param q 
 */
void enqueue (VType x, Queue q)
{
	if (isFull(q))
		unix_error("enqueue error");

	if (++q->size > q->capacity)
		unix_error("queue is overflow");

	int newRear = ++(q->rear) < q->capacity ? q->rear : 0;

	q->rear = newRear;
	q->array[newRear] = x;
}

/**
 * 出队
 * @param  q 
 * @return   
 */
VType dequeue (Queue q)
{
	if (isEmpty(q))
		unix_error("dequeue error");

	int newFront;
	VType result;

	result = q->array[q->front];
	// 新队头
	newFront = ++(q->front) < q->capacity ? q->front : 0;

	q->front = newFront;
	q->size--;

	return result;
}

/**
 * 返回队头元素
 * @param  q 
 * @return   
 */
VType front (Queue q)
{
	if (isEmpty(q))
		unix_error("front error");

	return q->array[q->front];
}

/**
 * 显示队列元素
 * @param q 
 */
void show (Queue q)
{
	printf("front is %d, rear is %d, size is %d\n", q->front, q->rear, q->size);
	if (isEmpty(q)) 
		return;
	
	for (int i = 0, maxIndex = q->capacity - 1; i < q->size; i++) {
		int tmp = i + q->front;
		tmp = tmp < maxIndex ?  tmp : tmp - q->capacity; 
		printf("队列第%d个元素%d\n", i + 1, q->array[tmp]);
	}
	
}

```



