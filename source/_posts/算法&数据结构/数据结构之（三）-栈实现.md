---
title: 数据结构之（三）--- 栈实现
categories:
  - 算法/数据结构
  - 数据结构
tags:
  - 栈
  - stack
abbrlink: b2596ee6
date: 2019-02-11 19:25:40

---

### 栈ADT概述

栈(stack)其实是一种特殊的表，插入后删除都只能从表的指定位置进行，这个位置成为栈顶。栈的插入叫入栈(push)，删除叫出栈(pop)，因为入栈和出栈都是在栈顶进行，因此最后入栈的元素最先出栈(后进先出:LIFO)，因此栈也叫LIFO表，换句话说，在任意时刻，只有栈顶元素是可见的。

因为栈其实是一个表，因此任何实现表的方法都能实现栈，通常有链表和数组两种实现方式，下面分别实现。



### 栈链表实现

首先是栈链表实现的ADT声明头文件stack.h:

```c
#ifndef _stack_h

typedef int VType;

struct StackNode;
typedef struct StackNode *ptrToNode;
typedef ptrToNode Stack;
typedef ptrToNode Node;

/**
 * 创建一个空栈
 * @return  
 */
Stack createStack (void);

/**
 * 检测是否空栈
 * @param  s
 * @return       
 */
int isEmpty (Stack s);

/**
 * 获取栈大小
 * @param  s
 * @return       
 */
int size (Stack s);


/**
 * 清空栈
 * @param s
 */
void deleteAll (Stack s);

/**
 * 入栈
 * @param Stack 
 * @param x     
 */
void push (Stack, VType x);

/**
 * 出栈
 * @param  stack 
 * @return       
 */
VType pop (Stack stack);

/**
 * 返回栈顶元素
 * @param  s
 * @return       
 */
VType top (Stack s);

/**
 * 展示栈数据
 * @param list 
 */
void show (Stack stack);


#endif /* _stack_h */
```

然后是显现文件stack.c:

```c
#include <stdlib.h>
#include <stdio.h>
#include "stack.h"

struct StackNode {
	VType value;
	struct StackNode *next;
};

/**
 * 显示unix风格的错误
 * @param msg 
 */
void unix_error (char *msg) 
{
	printf("%s\n", msg);
	exit(0);
}


void *Malloc (size_t size) {
	void *p;
	if ((p = malloc(size)) == NULL)
		unix_error("malloc error!");
	return p;
}

/**
 * 创建一个空栈
 * @return  
 */
Stack createStack (void)
{
	Stack s = (Stack)Malloc(sizeof (struct StackNode));
	s->next = NULL;

	return s;
}


/**
 * 检测是否空栈
 * @param  s 
 * @return       
 */
int isEmpty (Stack s) 
{
	return s->next == NULL;
}

/**
 * 获取栈大小
 * @param  s
 * @return       
 */
int size (Stack s)
{
	int count = 0;
	Node p = s;

	while (p->next != NULL) {
		count++;
		p = p->next;
	}

	return count;
}


/**
 * 清空栈
 * @param s 
 */
void deleteAll (Stack s)
{
	Node tmp, node = s->next;

	while (node != NULL) {
		tmp = node->next;
		free(node);
		node = tmp;
	}
	s->next = NULL;
}

/**
 * 入栈
 * @param s 
 * @param x     
 */
void push (Stack s, VType x) {
	Node node;

	node = (Node)Malloc(sizeof(struct StackNode));
	node->value = x;
	node->next = s->next;
	s->next = node;
}

/**
 * 出栈
 * @param  s 
 * @return       
 */
VType pop (Stack s)
{
	if (isEmpty (s))
		unix_error("pop error");

	VType result;

	Node node = s->next;
	s->next = node->next;
	result = node->value;
	free(node);

	return result;
}

/**
 * 返回栈顶元素
 * @param  s
 * @return       
 */
VType top (Stack s)
{
	if (isEmpty(s))
		unix_error("empty stack");

	return s->next->value;
}


/**
 * 展示栈数据
 * @param list 
 */
void show (Stack s)
{
	if (isEmpty(s)) {
		printf("当前是空栈\n");
		return;
	}
	int count = 1;
	Node n = s->next;
	while (n != NULL) {
		printf("从栈顶第%d个元素：%d\n", count++, n->value);
		n = n->next;
	}
}

```



### 栈数组实现

栈数组实现和链表实现的区别在于需要提前设置栈的大小，一遍初始化数组，但是它相比于链表实现的优势在于入栈和出栈少了频繁的malloc和free开销。

因为需要提前设置栈大小，因此创建栈实例时需要给出栈容量参数，下面是栈的数组直线的ADT头文件stack2.h:

```c
#ifndef _stack_h

struct StackRecord;
typedef struct StackRecord *Stack;

typedef int VType;

/**
 * 创建并初始化一个空栈
 * @param  maxElements 栈最大容量
 * @return             
 */
Stack createStack (int maxElements);


/**
 * 获取栈大小
 * @param  s
 * @return       
 */
int size (Stack s);

/**
 * 检测当期栈是否为空
 * @param  s 
 * @return   
 */
int isEmpty (Stack s);

/**
 * 检测当前栈是否满栈
 * @param  s 
 * @return   
 */
int isFull (Stack s);

/**
 * 清空栈
 * @param s [description]
 */
void deleteAll (Stack s);

/**
 * 释放栈
 * @param s 
 */
void disposeStack (Stack s);


/**
 * 入栈
 * @param x 入栈元素
 * @param s 
 */
void push (VType x, Stack s);

/**
 * 出栈
 * @param  s 
 * @return   
 */
VType pop (Stack s);


/**
 * 返回栈顶元素
 * @param  s 
 * @return   
 */
Vtype top (Stack s);


/**
 * 展示栈数据
 * @param list 
 */
void show (Stack s);

#endif /* _stack_h */
```

实现文件stack2.c:

```c
#include <stdio.h>
#include <stdlib.h>
#include "stack2.h"
#define EmptyTOS (-1)
#define MinStackSize (5)

struct StackRecord {
	int capacity; // 栈最大容量
	int topOfStack; // 栈顶下标
	VType *array; // 存储栈元素的数组
};


/**
 * 显示unix风格的错误
 * @param msg 
 */
void unix_error (char *msg) 
{
	printf("%s\n", msg);
	exit(0);
}

void *Malloc (size_t size) {
	void *p;
	if ((p = malloc(size)) == NULL)
		unix_error("malloc error!");
	return p;
}


/**
 * 创建并初始化一个空栈
 * @param  maxElements 栈最大容量
 * @return             
 */
Stack createStack (int maxElements)
{
	Stack s;

	if (maxElements < MinStackSize)
		unix_error("Stack size is too small");

	s = Malloc(sizeof (struct StackRecord));

	s->array = Malloc(sizeof (VType) * maxElements);

	s->capacity = maxElements
	deleteAll(s);

	return s;
}

/**
 * 获取栈大小
 * @param  s
 * @return       
 */
int size (Stack s)
{
	return s->topOfStack + 1;
}

/**
 * 检测当期栈是否为空
 * @param  s 
 * @return   
 */
int isEmpty (Stack s)
{
	return s->topOfStack == EmptyTOS;
}

/**
 * 检测当前栈是否满栈
 * @param  s 
 * @return   
 */
int isFull (Stack s)
{
	return size(s) == s->capacity;
}


/**
 * 清空栈
 * @param s [description]
 */
void deleteAll (Stack s) 
{
	s->topOfStack = EmptyTOS;
}

/**
 * 释放栈
 * @param s 
 */
void disposeStack (Stack s)
{
	if (s != NULL) {
		free (s->array);
		free(s);
	}
}

/**
 * 入栈
 * @param x 入栈元素
 * @param s 
 */
void push (VType x, Stack s)
{
	if (isFull(s))
		unix_error("Full stack");

	s->array[++(s->topOfStack)] = x;
}

/**
 * 出栈
 * @param  s 
 * @return   
 */
VType pop (Stack s)
{
	if (isEmpty(s))
		unix_error("Empty stack");

	return s->array[s->topOfStack--];
}

/**
 * 返回栈顶元素
 * @param  s 
 * @return   
 */
VType pop (Stack s)
{
	if (isEmpty(s))
		unix_error("Empty stack");

	return s->array[s->topOfStack];
}

/**
 * 展示栈数据
 * @param list 
 */
void show (Stack s)
{
	if (isEmpty(s)) {
		printf("当前是空栈\n");
		return ;
	}
	for (int i = s->topOfStack; i >= 0; i--) {
		printf("从栈顶第%d个元素：%d\n", (s->topOfStack - i), s->array[i]);
	}
}


```

