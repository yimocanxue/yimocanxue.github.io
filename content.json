[{"title":"gitlab系列教程之1-安装","date":"2017-07-07T11:11:16.000Z","path":"2017/07/07/gitlab系列教程之1-安装/","text":"一、安装gitlabe1.1、安装docker安装环境为centos_7.0 3.10.0-327.10.1.el7.x86_64，参考链接https://docs.docker.com/engine/installation/linux/centos/#install-docker。安装方式有两种，一种是通过yum安装，另外一种是下载RPM包手动安装，这里采用第一种方式。 这里以安装docker-ce stable为例，docker-ee安装类似，可以参照上面的链接。 1.1.1 设置yum repository安装yum-utils，它提供yum-config-manager这个工具包： 1$ sudo yum install -y yum-utils 添加docker资源库： 123$ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 如果需要安装edage版，则执行下面的命令启用其repository： 1$ sudo yum-config-manager --enable docker-ce-edage 1.1.2 安装更新yum的安装包索引： 1$ sudo yum makecache fast 安装最新版的docker: 1$ sudo yum install docker-ce 输入docker version输出类似下面的内容则表示安装成功。 启动docker服务 1$ sudo systemctl start docker.service 1.1.3 安装docker-compose因为一个完整的gitlab应用包含gitlab容器、redis、postgresql等服务，每个服务都启动一个docker实例，那么gitlab的管理就会很麻烦，docker-compose就是这么一个管理多容器应用的神器，它基于一个yml配置文件搞定依赖服务之前的管理。 由于docker-compose依赖Python-pip，因此先安装它： 1$ sudo yum install -y python-pip 对安装的pip进行升级： 1$ sudo pip install --upgrade pip 利用pip安装docker-compose 1$ sudo pip install docker-compose 安装后查看版本如下： 1.2、安装gitlabgitlab依赖redis、postgresql、其中redis提供缓存服务，postgresql负责持久化数据存储(当然也可以是MySQL)，因此需要开启三个容器，大致步骤如下。 启动postgresql容器 12345$ docker run --name gitlab-postgresql -d \\ --env &apos;DB_NAME=gitlabhq_production&apos; \\ --env &apos;DB_USER=gitlab&apos; --env &apos;DB_PASS=password&apos; \\ --volume /srv/docker/gitlab/postgresql:/var/lib/postgresql \\ sameersbn/postgresql:9.4-12 启动redis容器 123docker run --name gitlab-redis -d \\ --volume /srv/docker/gitlab/redis:/var/lib/redis \\ sameersbn/redis:latest 然后再启动gitlab容器，然后通过–link连接redis和postgresql容器 1234567docker run --name gitlab -d \\ --link gitlab-postgresql:postgresql --link gitlab-redis:redisio \\ --publish 10022:22 --publish 10080:80 \\ --env &apos;GITLAB_PORT=10080&apos; --env &apos;GITLAB_SSH_PORT=10022&apos; \\ --env &apos;GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alpha-numeric-string&apos; \\ --volume /srv/docker/gitlab/gitlab:/home/git/data \\ sameersbn/gitlab:8.4.4 这样相当复杂，因此我们可以把这些启动配置写到一个yml文件里面去，让docker-compose帮我们来管理这些容器，而这些容器之间的compose配置，已经有大牛贡献出来了（点击这里查看）。因此我们这里把它的配置文件下载下来 1$ wget https://raw.githubusercontent.com/sameersbn/docker-gitlab/master/docker-compose.yml 然后修改里面的配置项（见下节），然后一条命令即可启动gitlab服务 1$ docker-compose up 不过出现如下错误： 1docker: Error response from daemon: mkdir /data/docker/mnt/overlay/e37098a0043c2bd200b919c4cd466a1cfe98a03865b08be82efa215e32e92196-init/merged/dev/shm: invalid argument. 查了很久，找到两篇帖子（看这里,还有这里），说啥的都有，不过隐约觉得应该是内核版本问题（最新内核版本），具体内核升级参照这里。 果然，升级内核后不再报错了。 1.3、配置gitlab这里只列出有配置改动的部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990version: &apos;2&apos;services: redis: restart: always image: sameersbn/redis:latest command: - --loglevel warning volumes: - /server/docker/gitlab/redis:/var/lib/redis:Z postgresql: restart: always image: sameersbn/postgresql:9.6-2 volumes: - /server/docker/gitlab/postgresql:/var/lib/postgresql:Z environment: # postgsql的账户设置 - DB_USER=gitlab - DB_PASS=8uf0s3cxdf - DB_NAME=gitlabhq_production - DB_EXTENSION=pg_trgm gitlab: restart: always image: sameersbn/gitlab:9.0.5 depends_on: - redis - postgresql ports: # 把容器内nginx的80端口隐射到宿主机的10080端口上 - &quot;10080:80&quot; # 把容器内ssh的22号端口映射到宿主机的10022端口上 - &quot;10022:22&quot; volumes: # 通过数据卷把gitlab的数据挂载到/server/docker/gitlab/gitlab目录下，这样容器重启后数据就不会丢失了 - /server/docker/gitlab/gitlab:/home/git/data:Z environment: - DEBUG=false - DB_ADAPTER=postgresql - DB_HOST=postgresql - DB_PORT=5432 - DB_USER=gitlab - DB_PASS=8uf0s3cxdf - DB_NAME=gitlabhq_production - REDIS_HOST=redis - REDIS_PORT=6379 # 修改时区 - TZ=Asia/Shanghai - GITLAB_TIMEZONE=Beijing - GITLAB_HTTPS=false - SSL_SELF_SIGNED=false # 发布gitlab应用的主机名称 - GITLAB_HOST=gitlab.cn-etc.com - GITLAB_PORT=10080 - GITLAB_SSH_PORT=10022 - GITLAB_RELATIVE_URL_ROOT= - GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alphanumeric-string - GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alphanumeric-string - GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alphanumeric-string - GITLAB_ROOT_PASSWORD=cnetc123 - GITLAB_ROOT_EMAIL=gitlab@cn-etc.com - GITLAB_NOTIFY_ON_BROKEN_BUILDS=true - GITLAB_NOTIFY_PUSHER=false - GITLAB_EMAIL=gitlab@cn-etc.com - GITLAB_EMAIL_REPLY_TO=gitlab@cn-etc.com - GITLAB_INCOMING_EMAIL_ADDRESS=gitlab@cn-etc.com # 发送邮件时的显示名称 - GITLAB_EMAIL_DISPLAY_NAME=Gitlab系统 - GITLAB_BACKUP_SCHEDULE=daily - GITLAB_BACKUP_TIME=01:00 # SMTP配置 - SMTP_ENABLED=true - SMTP_DOMAIN=smtp.exmail.qq.com - SMTP_HOST=smtp.exmail.qq.com - SMTP_PORT=465 - SMTP_USER=gitlab@cn-etc.com - SMTP_PASS=Gitlab123 - SMTP_STARTTLS=true - SMTP_AUTHENTICATION=login 重新启动 1$ docker-compose up 至此，gitlab安装完成，登录http://gitlab.cn-etc.com:10080 去注册用户新建group、project开干。 二、持续集成(CI/CD)2.1 继续集成介绍为了更好的理解gitlab持续集成的配置和管理，有必要详细理顺与持续集成相关概念，这里单独另开了一篇来说明这些概念，点击这里查看。 2.1 安装gitlab-runnerrunner就是一个用来跑集成任务的特殊进程，可以和gitlab在同一台服务器，也可以安装在其它服务器上。 添加gitlab-runner资源库 1$ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash 然后安装 1$ sudo yum install -y gitlab-ci-multi-runner","tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://xuh.io/tags/gitlab/"},{"name":"安装","slug":"安装","permalink":"https://xuh.io/tags/安装/"},{"name":"docker","slug":"docker","permalink":"https://xuh.io/tags/docker/"}]},{"title":"算法分析","date":"2017-06-10T15:07:26.000Z","path":"2017/06/10/算法分析/","text":"算法（algorithm）是为求解一个问题需要遵循的、被清楚指定的简单指令集合。衡量算法合理性的两个指标是运行时间和占用资源（比如内存）。 分析估计算法性能一般来说是一个理论问题，因此需要有一套正式的系统理论，这个理论基础就是数学。 数学基础定义算法分析用到以下4中定义。 1、如果存在正常数c和$ n_0$使得当$ N \\geq n_0 时T(N) \\leq cf(N)，则记为T(N)=O(f(N)) 。$ 2、如果存在正常数c和$ n_0 $使得当$ N \\geq n_0 时T(N) \\geq cg(N)，则记为T(N) = Ω(g(N))。$ 3、$T(N)= \\Theta (h(N))当且仅当T(N)=O(h(N))且T(N)=Ω(h(N))。$ 4、$ 如果T(N)=O(p(N))且T(N) \\neq \\Theta (p(N))，则T(N) = o(p(N))。$ 通常在一些点上一个函数的值大于另外一个函数的值，比较这些点的大小往往是没有意义的，在算法分析中我们通常是要比较两个函数的增长趋势，即相对增长率。 从不等式的角度来看，定义1的含义为$T(N)$的相对增长率小于或等于$f(N)$，及$T(N)以不大于f(N)的趋势增长，因此f(N)是T(N)的一个$上界。 定义2含义为$T(N)以大于或等于g(N)的增长率增长，g(N)为T(N)的一个$下界。 定义3表示两个函数的增脏率相同。 定义4与定义1的区别是定义1包含增长率相同的可能，定义1的表方法称着大O记法，定义4的表示方法称为小o记法。 几个重要的法则法则1$ 如果T_1(N)=O(f(N))且T_2(N)=O(g(N))，那么$ $ T_1(N) + T_2(N)=max(O(f(N),O(g(N)))$ $ T_1(N) T_2(N)=O(f(N) g(N))$ 法则2$如果T(N)是一个k次多项式，则T(N)=\\Theta(N^k)$ 法则3$对任意常数k,log^k N = O(N)$ 注意 在大O表示发中，忽略常数和低阶项，比如$T(N) = O(2N^2)$和$T(N)=O(N^2 + N)$都应该表示为$T(N)=O(N^2)$ 可以通过计算极限$\\lim_{n-&gt;\\infty}{f(N)/g(N)}$来确定两个函数$f(N)和g(N)$的增长率。如果极限为0，则$f(N)=o(g(N))$;如果为不等于0的常数则$f(N)=\\Theta(g(N))$;如果极限是$\\infty$，则$g(N)=o(f(N))$;如果极限摆动，则二者无关(算法分析中不会出现这种情况)。","tags":[{"name":"算法分析","slug":"算法分析","permalink":"https://xuh.io/tags/算法分析/"}]},{"title":"数学证明方法与递归","date":"2017-06-09T10:34:34.000Z","path":"2017/06/09/数学证明方法与递归/","text":"证明数据结构分析中的结论经常用到两种方法,归纳法和反证法，这两种方法比较直观简单，只有在不得已的情况下才使用高大上的高等数学的证明方法。证明一个定理不成立最好的方法是反证法。 归纳法 归纳法证明的两个关键步骤： 基准情形，归纳假设 证明基准情形归纳法证明第一步是证明基准情形，即对确定的某个小范围（通常是退化的）值的正确性，这一步通常是最简单直接的。 归纳假设接下来是进行归纳假设，一般来说，这意味着假设定理对直到某个有限的数k的所有情况都成立，然后以此作为假设前提，证明定理对下一个值（通常是k+1）也成立，至此证明完成。 下面通过归纳法证明下面的定理。 斐波那契数列:$ F_0 = 1,F_1 = 1,F_2 = 2,F_3 = 3,F_4 = 5,…,Fi = F{i-1} + F_{i-2} $, 对于$ i \\geq 1 满足 {F_i &lt; ({ 5 \\over 3})^i} $ 证明: 首先，证明基准情形，对于$ F_1 = 1 &lt; {5 \\over 3},F2 = 2 &lt; {25 \\over 9 }成立。$ 现假设对于$ i = 1,2,…,k $欲证定理成立，在此基础上如果我们能证明$ F{k+1} &lt; ({5 \\over 3})^{k+1} $成立，则定理成立。根据定义我们有： $ F_{k+1} = Fk + F{k-1} $ $ &lt; ({5 \\over 3})^k + ({5 \\over 3})^{k-1} $ $ &lt; ({3 \\over 5})({5 \\over 3})^{k+1} + ({3\\over5})^2({5 \\over 3})^{k+1} $ $ &lt; ({24 \\over 25})({5 \\over 3})^{k+1} $ $ &lt; ({5 \\over 3})^{k+1} $ 以此定理成立。 如果 $ N \\geq 1,则\\sum_{i=1}^N i^2 = { N(N+1)(2N+1) \\over 6 } $ 证明 当N=1时定理成立,现假设命题对 $ 1\\leq k \\leq N $ 成立,现证明对于N+1也成立 $ \\sum{i=1}^{N+1} i^2 = \\sum{i=1}^N i^2 + (N+1)^2 $ $ ={N(N+1)(2N+1) \\over 6} + (N+1)^2 $ $ =(N+1)[{N(2N+1) \\over 6} + (N+1)] $ $ =(N+1){(2N^2 + 7N + 6) \\over 6} $ $ ={(N+1)[(N+1)+2][2(N+1)+1] \\over 6} $ 于是N+1时也成立,命题得证。 反证法 费马猜想（费马素数），对于$ n \\in N(自然数)，F_n = 2^{2^n} + 1 $是素数 这是费马老先生当时随便胡写在书页留白处的，并且说自己已经有证明方法了，可以这里写不下，我擦，据说好几十年没人证明出来，也是当时的计算能力有限，实际上当n=0,1,2,3,4时，$ F_n $分别是 3,5,17,257,65537都是素数，但是ｎ＝４时已经非常大了,但是当ｎ＝５时，$ F_n=614×6700417 $ ,这就是反证法 证明存在无穷多个素数 证明： 为了证明命题成立，我们先假设不成立，于是存在某个最大的素数$ P_k ,令P_1,P_2,..,P_k $是依序排列的所有素数，$ 令N = P_1P_2P_3…P_k + 1,显然N是比P_k $大的数， 根据假设N不是素数,可是$ P_1,P2,…,P_k $都不能整除N,因为整除的结果总有余数１，这就产生了 矛盾，因此假设不成立，因此原命题成立。","tags":[{"name":"证明方法","slug":"证明方法","permalink":"https://xuh.io/tags/证明方法/"},{"name":"递归","slug":"递归","permalink":"https://xuh.io/tags/递归/"}]},{"title":"数学基础知识","date":"2017-06-07T14:54:13.000Z","path":"2017/06/07/数学基础知识/","text":"算法分析的基础是数学，但是只从走出校门，就很少再接触这些东西，基本上都还给老师了，最近重读算法分析这本书，好多公式又冒出来了，为了以后再接触方便，这里特意记录下来。 指数$$ X^AX^B=X^{A+B} $$$$ { X^A \\over X^B } = X^{A-B} $$$$ (X^A)^B = X^{AB} $$$$ X^N + X^N = 2X^N \\neq X^{2N} $$$$ 2^N + 2^N = 2^{N+1} $$ 对数在计算机科学中，除非又特殊说明，所有对数都是以2为底。 对数定义 $ X^A = B ，当且仅当 \\log_XB = A $ 根据定义可以推理出几个定理。 定理1$ \\log_AB = { \\log_CB \\over \\log_CA}; C &gt; 0 $ 定理2$ logAB = logA + logB $ 一些有用的公式$$ log{A \\over B} = logA - logB $$$$ log(A^B) = BlogA $$$$ logX &lt; X (对所有X&gt;0成立) $$$$ log1 = 0,log2 = 1,log1024=10, log1048576=20 $$ 级数$$ \\sum_{i=0}^N 2^i = 2^{N+1} - 1 $$ $$ \\sum_{i=0}^N A^i = { A^{N+1} - 1 \\over A - 1} $$ $$ \\sum_{i=0}^N A^i \\leq {1 \\over 1 - A}; (0 &lt; A &lt; 1) $$ $$ \\sum_{i=0}^\\infty = {1 \\over 1 - A} ;(0 &lt; A &lt; 1) $$ $$ \\sum_{i=1}^N = { N(N + 1) \\over 2 } \\approx {N^2 \\over 2} $$ $$ \\sum_{i=1}^N i^2 = {N(N + 1)(2N + 1) \\over 6 } \\approx {N^3 \\over 3} $$ $$ \\sum_{i=1}^N i^k \\approx { N^{k+1} \\over | k + 1 |};k \\neq -1 $$ 欧拉常数上面最后一个公式,当k=-1时不成立，此时我们需要另外的一个公式，这个公式在计算机科学中使用要远比在其它学科中使用得多。 $$ \\sum_{i=1}^N { 1 \\over i } = H_N \\approx \\log_e N,H_N称为调和数 $$ 式中误差γ趋近于0.57721566，这个值称为欧拉常数 两个代数运算公式$$ \\sum_{i=1}^N f(N) = Nf(N) $$ $ \\sum_{i=n_0}^N f(i) = A $ $ \\sum_{i=1}^N f(i) = B $ $ \\sum_{i=1}^{n_0 - 1}f(i) = C,则 A = B - C $ 模运算 如果A - B能够被N整除，那么A与B模N同余（congruent），记为： $ A \\equiv B(mod N) $ 推论 若 $ A \\equiv B(mod N) ，则 A + C \\equiv B + C(mod N) $若 $ A \\equiv B(mod N) ，则 AD \\equiv BD(mod N) $","tags":[{"name":"数学基础","slug":"数学基础","permalink":"https://xuh.io/tags/数学基础/"}]},{"title":"UITabBar的基本用法","date":"2017-06-06T08:20:39.000Z","path":"2017/06/06/UITabBar的基本用法/","text":"","tags":[]},{"title":"集合类型之0-概述","date":"2017-06-05T11:51:02.000Z","path":"2017/06/05/集合类型之0-概述/","text":"集合类型所有编程语言中，元素集合都是最重要的数据类型，Swift提供三种集合类型存储集合数据：Arrays(数组)、Sets(集合)、Dictionaries(字典)。 Arrays: 有序数据集Sets: 无序不重复数据集Dictionaries: 无序键值对 注意：1、三种中集合都被实现为泛型集合2、三种集合都是值类型3、集合的可变性有声明关键字let、var决定4、在不需要改变集合的时候，尽量以let声明成常量","tags":[{"name":"集合","slug":"集合","permalink":"https://xuh.io/tags/集合/"}]},{"title":"集合类型之3-字典","date":"2017-06-05T11:50:46.000Z","path":"2017/06/05/集合类型之3-字典/","text":"","tags":[]},{"title":"集合类型之2-集合","date":"2017-06-05T11:50:38.000Z","path":"2017/06/05/集合类型之2-集合/","text":"","tags":[]},{"title":"集合类型之1-数组","date":"2017-06-05T11:50:04.000Z","path":"2017/06/05/集合类型之1-数组/","text":"","tags":[]},{"title":"为编译安装的nginx和php-fpm定制服务启动脚本","date":"2015-11-29T05:26:38.000Z","path":"2015/11/29/为编译安装的nginx和php-fpm定制服务启动脚本/","text":"源码编译安装的nginx和php-fpm没有centos自带的服务那样可以通过start|stop|restart等管理服务，只能自己定制了。 nginx启动脚本/etc/init.d/nginx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#!/bin/bash## Startup script for Nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: Nginx is an HTTP(S) server, HTTP(S) reverse proxy and IMAP/POP3 proxy server# processname: nginx# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ \"$NETWORKING\" = \"no\" ] &amp;&amp; exit 0nginx=\"/alidata/server/nginx/sbin/nginx\"prog=$(basename $nginx)NGINX_CONF_FILE=\"/alidata/server/nginx/conf/nginx.conf\"[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxstart() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 echo -n $\"Starting $prog: \" daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $\"Stopping $prog: \" killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $\"Reloading $prog: \" killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case \"$1\" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $\"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;\" exit 2esac 保存后赋予执行权限，加入开机启动 12sudo chmod +x /etc/init.d/nginxsudo /sbin/chkconfig nginx on PHP-FPM启动脚本/etc/init.d/php-fpm12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 #!/bin/bash## Startup script for the PHP-FPM server.## chkconfig: 345 85 15# description: PHP is an HTML-embedded scripting language# processname: php-fpm# config: /usr/local/php/etc/php.ini# Source function library.. /etc/rc.d/init.d/functionsPHP_PATH=/alidata/serverDESC=\"php-fpm daemon\"NAME=php-fpm# php-fpm路径DAEMON=$PHP_PATH/php/sbin/$NAME# 配置文件路径CONFIGFILE=$PHP_PATH/php/etc/php-fpm.conf# PID文件路径(在php-fpm.conf设置)PIDFILE=$PHP_PATH/php/var/run/$NAME.pidSCRIPTNAME=/etc/init.d/$NAME# Gracefully exit if the package has been removed.test -x $DAEMON || exit 0rh_start() &#123; $DAEMON -y $CONFIGFILE || echo -n \" already running\"&#125;rh_stop() &#123; kill -QUIT `cat $PIDFILE` || echo -n \" not running\"&#125;rh_reload() &#123; kill -HUP `cat $PIDFILE` || echo -n \" can't reload\"&#125;case \"$1\" in start) echo -n \"Starting $DESC: $NAME\" rh_start echo \".\" ;; stop) echo -n \"Stopping $DESC: $NAME\" rh_stop echo \".\" ;; reload) echo -n \"Reloading $DESC configuration...\" rh_reload echo \"reloaded.\" ;; restart) echo -n \"Restarting $DESC: $NAME\" rh_stop sleep 1 rh_start echo \".\" ;; *) echo \"Usage: $SCRIPTNAME &#123;start|stop|restart|reload&#125;\" &gt;&amp;2 exit 3 ;;esacexit 0 同样赋予执行权限和设置开机启动： 12sudo chmod +x /etc/init.d/php-fpmsudo /sbin/chkconfig php-fpm on","tags":[{"name":"启动脚本","slug":"启动脚本","permalink":"https://xuh.io/tags/启动脚本/"},{"name":"nginx","slug":"nginx","permalink":"https://xuh.io/tags/nginx/"},{"name":"php-fpm","slug":"php-fpm","permalink":"https://xuh.io/tags/php-fpm/"}]},{"title":"centos6.5安装Memcached和php memcached扩展","date":"2015-11-29T05:12:15.000Z","path":"2015/11/29/centos6-5安装Memcached和php-memcached扩展/","text":"安装memcached服务$ yum -y install memcached 把memcached加入开机启动 $ chkconfig memcached on 这个比较简单，yum同时安装依赖的libevent，安装后只要执行memcached -h有输出即安装成功,memcached的默认启动参数可以在/etc/sysconfig/memcached 修改。 安装memcached扩展依赖的libmemcached12345$ wget https://launchpad.net/libmemcached/1.0/1.0.18/+download/libmemcached-1.0.18.tar.gz$ tar zxvf libmemcached-1.0.18.tar.gz $ cd libmemcached-1.0.18$ ./configure -prefix=/usr/local/libmemcached -with-memcached$ make &amp;&amp; make install 安装php-devel如果在你php的bin目录下有phpize这个东东这步可以省略，phpize主要用来编译php外挂扩展 $ yum -y install php-devel 安装igbinary扩展123456$ wget http://pecl.php.net/get/igbinary-1.2.1.tgz$ tar zxvf igbinary-1.2.1.tgz$ cd igbinary-1.2.1$ /alidata/server/php/bin/phpize$ ./configure --with-php-config=/alidata/server/php/bin/php-config$ make &amp;&amp; make install 然后在在php.ini中增加extension=igbinary.so 安装memcached扩展123456$ wget http://pecl.php.net/get/memcached-2.2.0.tgz$ tar zxvf memcached-2.2.0.tgz$ cd memcached-2.2.0$ /alidata/server/php/bin/phpize$ ./configure -enable-memcached -enable-memcached-igbinary -enable-memcached-json -with-php-config=/alidata/server/php/bin/php-config -with-zlib-dir -with-libmemcached-dir=/usr/local/libmemcached -prefix=/usr/local/phpmemcached --disable-memcached-sasl$ make &amp;&amp; make install 最后编辑php.ini，加入memcached扩展extension=memcached.so 正常情况安装就成功了。","tags":[{"name":"php扩展","slug":"php扩展","permalink":"https://xuh.io/tags/php扩展/"},{"name":"memcached","slug":"memcached","permalink":"https://xuh.io/tags/memcached/"}]},{"title":"查询linux版本方法","date":"2015-11-29T03:54:33.000Z","path":"2015/11/29/查询linux版本方法/","text":"1、查看/etc/redhat-release $ cat /etc/redhat-release 2、查看rpm包版本 $ rpm -q centos-release 如果是redhat则执行rpm -q redhat-release 3、所有版本通用的lsb_release 1234567#lsb_release -aLSB Version: :base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarchDistributor ID: CentOSDescription: CentOS release 6.5 (Final)Release: 6.5Codename: Final 4、使用uname-a","tags":[{"name":"linux","slug":"linux","permalink":"https://xuh.io/tags/linux/"},{"name":"发型版本","slug":"发型版本","permalink":"https://xuh.io/tags/发型版本/"}]},{"title":"一个 git hook自动部署脚本","date":"2015-11-28T03:21:44.000Z","path":"2015/11/28/一个-git-hook自动部署脚本/","text":"http://www.ihorve.com/?p=234123456789101112131415161718192021222324252627282930313233343536373839#!/bin/sh## git autodeploy script when it matches string \"[deploy]\"## Usage:# 1. put this into the post-receive hook file itself below# 2. `chmod +x post-receive`# 3. Done!# Check the remote git repository whether it is bareIS_BARE=$(git rev-parse --is-bare-repository)if [ -z \"$IS_BARE\" ]; then echo &gt;&amp;2 \"fatal:post-receive:IS_NOT_BARE\" exit 1fi# Get the latest commit subjectSUBJECT=$(git log -1 --pretty=format:\"%s\")# Deploy the HEAD source to publishIS_PULL=$(echo \"$SUBJECT\" | grep \"\\[deploy\\]\")if [ -z \"$IS_PULL\" ];then echo &gt;&amp;2 \"tips:post-receive:IS_NOT_PULL\" exit 1fi# Check the deploy dir whether is existsDEPLOY_DIR=/home/wwwif [ ! -d $DEPLOY_DIR ]; then echo &gt;&amp;2 \"fatal:post-receive:DEPLOY_DIR_NOT_EXISTS:\\\"$DEPLOY_DIR\\\"\" exit 1fi# Check the deploy dir whether it is git repository#IS_GIT=$(git rev-parse --git-dir 2&gt;/dev/null)#if [ -z \"$IS_GIT\" ] ;then# echo &gt;&amp;2 \"fatal:post-receive:IS_NOT_GIT\"# exit 1#fi# Goto the deploy dir and pull the latest sourcescd $DEPLOY_DIR# env -i git reset --hardenv -i git pull","tags":[{"name":"git","slug":"git","permalink":"https://xuh.io/tags/git/"}]},{"title":"让nginx支持path_info","date":"2015-11-28T03:21:44.000Z","path":"2015/11/28/让nginx支持path-info/","text":"nginx默认是不支持path_info模式的，也就是说不支持index.php/*这样的url，因此像Thinkphp中URL model为2的那种路径方式nginx不支持。 只要修改虚拟主机的下面三个地方即可： 12345678910location ~ .php &#123; #删除.php后的$ fastcgi_pass soopj_phpfcgi; fastcgi_index default.php; fastcgi_split_path_info ^((?U).+.php)(/?.+)$; #增加这句 fastcgi_param PATH_INFO $fastcgi_path_info; #增加这句 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;","tags":[{"name":"nginx","slug":"nginx","permalink":"https://xuh.io/tags/nginx/"}]},{"title":"CentOS安装samba服务","date":"2015-11-28T03:21:44.000Z","path":"2015/11/28/CentOS安装samba服务/","text":"检查是否有安装samba服务： $ rpm -qa | grep samba 如果没安装则yum安装 $ yum -y install samba samba-client samba-common 默认的安装目录是/etc/samba，配置文件为smb.conf,先备份下smb文件$ cd /etc/samba$ cp smb.conf smb.conf.bak 然后编辑smb.conf加入以下内容： 123456[remote_dev] path = /alidata/nginx_www/wx.soopj.com public =no writable = yes write list = @www valid users = @www @www是客户端登录所需要的用户，设置nginx的用户密码： $ smbpasswd -a www 为了避免在启动Samba时出现以下警告信息：rlimit_max: increasing rlimit_max (1024) tominimum Windows limit (16384)，配置内核参数 12345$ ulimit -n 16384$ vi /etc/security/limits.conf#在最后加入以下内容* - nofile 16384 然后运行testparm检测配置文件。 然后启动服务，关闭防火墙： 123$ service smb start$ service nmb start$ service iptables stop centos7后启动服务由systemctl管理，防火墙换成firewalld，因此命令稍有不同。然后客户端即可测试。","tags":[{"name":"samba","slug":"samba","permalink":"https://xuh.io/tags/samba/"}]}]